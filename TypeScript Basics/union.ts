/* 
Union type (Объедененные типы) 

Narrowing types (Сужение типов) 
*/

/* 
Что делаеть если мы хотим типизировать переменную, но при этом нам бы хотелось, чтобы данная переменная
принимала несколько типов.
Мы можем воспользоваться оператором "|", он говорит TS что тут может лежать как тип с права от черты, так и
тип слева от черты.

*Мы можем объеденять не только два типа но и более string | number | boolean
*/

let numberOrString: number | string = "5";
numberOrString = 5;

let booleanOrNull: boolean | null = null;
booleanOrNull = true;

let arrayOrObject: [] | {} = {};
arrayOrObject = [];

/* 
Исходя из полученных знаний, давайте напишем функцию, которая будет принимать два аргумента.
Они могут быть как числами, так и строками.
Возвращать она должна результат сложения.
*/

const add = (n1: number | string, n2: number | string) => {
  /* const result = n1 + n2; - Operator '+' cannot be applied to types 'string | number' and 'string | number'.
При попытке решить данную задачу влом, мы сразу же столкнемся с ошибкой.
Так как мы указали что аргументы могут быть и строкой, и числом, TS не знает как правильно себя вести с данным 
аргументом, что можно, а что нельзя.
Поэтому нам необходимо использовать сужение типов.
Тоесть для каждого типа описать свой алгоритм действий. 
*/

  if (typeof n1 === "string" || typeof n2 === "string") {
    return Number(n1) + Number(n2);
  } else {
    return n1 + n2;
  }
};

export {};
